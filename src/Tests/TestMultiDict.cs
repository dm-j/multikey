// // <auto-generated>
// // This code was generated by a tool.
// //
// // Changes to this file may cause incorrect behavior and will be lost if
// // the code is regenerated.
// // </auto-generated>
//
// // This class serializes/deserializes to Json via System.Text.Json
// // To enable Newtonsoft.Json, define the following constant in your project: MULTIKEY_USE_NEWTONSOFT_JSON
//
// #nullable enable
//
// using System;
// using System.Collections;
// using System.Collections.Generic;
// using System.Collections.Immutable;
// using System.Text.Json;
// using SJson = System.Text.Json.Serialization;
// #if MULTIKEY_USE_NEWTONSOFT_JSON
// using NJson = Newtonsoft.Json;
// #endif
//
// namespace TestProject
// {
//     /// <summary>
//     /// Represents a specialized immutable dictionary of TestItem.
//     /// </summary>
//     /// <remarks>
//     /// The <see cref="TestMultiDict"/> class provides efficient lookup capabilities 
//     /// for items using both primary and secondary keys. The primary key allows for direct access to individual items,
//     /// while the secondary key allows for grouped access to items sharing the same secondary key.
//     /// </remarks>
//     /// <example>
//     /// The following example demonstrates how to use the <see cref="TestMultiDict"/>:
//     /// <code>
//     /// TestMultiDict dictionary = new TestMultiDict}();
//     /// Int32 primaryKey = /* any Int32 value */ default;
//     /// String secondaryKey = /* any String value */ default;
//     /// TestItem byPrimary = dictionary[primaryKey]; // Returns 1 item or throws exception
//     /// IReadOnlyList<TestItem> bySecondary = dictionary[secondaryKey]; // Returns 0+ items
//     /// </code>
//     /// </example>
// #if MULTIKEY_USE_NEWTONSOFT_JSON
// [NJson.JsonConverter(typeof(TestMultiDictNewtonsoftConverter))]
// #endif
//     [SJson.JsonConverter(typeof(ImmutableMultiKeyDictionarySystemConverter))]
//     public sealed partial record TestMultiDict : IReadOnlyDictionary<Int32, TestItem2>
//     {
//         private readonly ImmutableList<TestItem2?> _items;
//
//         private ImmutableDictionary<Int32, int>? _primaryIndex; // Will be initialized lazily
//
//         private ImmutableDictionary<String, ImmutableHashSet<int>>? _secondaryIndex; // Will be initialized lazily
//
//         static TestMultiDict()
//         {
//             // These two assignments will be filled in by source generation, supplied by user
//             PrimarySelector = (Func<TestItem2, Int32>)(item => item.Primary);
//             SecondarySelector = (Func<TestItem2, String>)(item => item.Secondary);
//         }
//
//         private static readonly Func<TestItem2, Int32> PrimarySelector;
//
//         private static readonly Func<TestItem2, String> SecondarySelector;
//
//         private ImmutableDictionary<Int32, int> PrimaryIndex =>
//             _primaryIndex ??= _items
//                 .Select((item, index) => (item, index))
//                 .Where(i => i.item is not null)
//                 .ToImmutableDictionary(key => PrimarySelector(key.item!), value => value.index);
//
//         private ImmutableDictionary<String, ImmutableHashSet<int>> SecondaryIndex =>
//             _secondaryIndex ??= _items
//                 .Select((item, index) => (item, index))
//                 .Where(i => i.item != null)
//                 .GroupBy(item => SecondarySelector(item.item!))
//                 .ToImmutableDictionary(group => group.Key, group => group.Select(x => x.index).ToImmutableHashSet());
//
//         public TestMultiDict()
//         {
//             _items = new List<TestItem2?>().ToImmutableList();
//         }
//
//         public TestMultiDict(IEnumerable<TestItem2> items)
//         {
//             _items = items.ToImmutableList()!;
//         }
//
//         private TestMultiDict(ImmutableList<TestItem2?> items, ImmutableDictionary<Int32, int> primaryIndex,
//             ImmutableDictionary<String, ImmutableHashSet<int>> secondaryIndex)
//         {
//             _items = items;
//             _primaryIndex = primaryIndex;
//             _secondaryIndex = secondaryIndex;
//         }
//
//         public TestItem2 this[Int32 primary] => _items[PrimaryIndex[primary]]!;
//
//         public IEnumerable<Int32> Keys => PrimaryIndex.Keys;
//         public IEnumerable<String> KeysSecondary => SecondaryIndex.Keys;
//         public IEnumerable<TestItem2> Values => _items.Where(i => i is not null)!;
//
//         public IReadOnlyList<TestItem2> this[String secondary] =>
//             SecondaryIndex.TryGetValue(secondary, out var result)
//                 ? result.Select(i => _items[i]!).ToList().AsReadOnly()
//                 : ((List<TestItem2>) []).AsReadOnly();
//
//         public bool ContainsKey(Int32 key) =>
//             PrimaryIndex.ContainsKey(key);
//
//         public bool ContainsKeySecondary(String key) =>
//             SecondaryIndex.ContainsKey(key);
//
//         public bool TryGetValue(Int32 primaryKey, out TestItem2 item2)
//         {
//             if (PrimaryIndex.TryGetValue(primaryKey, out var index))
//             {
//                 item2 = _items[index]!;
//                 return true;
//             }
//
//             item2 = default!;
//             return false;
//         }
//
//         public bool TryGetValue(String secondaryKey, out IReadOnlyList<TestItem2> items)
//         {
//             if (SecondaryIndex.TryGetValue(secondaryKey, out var indexes))
//             {
//                 items = indexes.Select(i => _items[i]!).ToList().AsReadOnly();
//                 return true;
//             }
//
//             items = default!;
//             return false;
//         }
//
//         public TestMultiDict Add(TestItem2 item2)
//         {
//             var primaryKey = PrimarySelector(item2);
//
//             if (PrimaryIndex.ContainsKey(primaryKey))
//                 throw new ArgumentException("An item with the same primary key already exists in the dictionary.",
//                     nameof(_primaryIndex));
//
//             return new(_items.Add(item2)!);
//         }
//
//         public TestMultiDict Remove(Int32 primary)
//         {
//             if (!PrimaryIndex.TryGetValue(primary, out var index))
//                 return this;
//
//             return new(_items.Remove(_items[index])!);
//         }
//
//         public TestMultiDict Remove(TestItem2 item2) =>
//             new(_items.Remove(item2)!);
//
//         public TestMultiDict SetItem(TestItem2 item2)
//         {
//             var primaryKey = PrimarySelector(item2);
//
//             if (!PrimaryIndex.TryGetValue(primaryKey, out var index))
//             {
//                 return Add(item2);
//             }
//
//             return new(_items.SetItem(index, item2)!);
//         }
//
//         public TestMultiDict Compact() =>
//             new(_items.Where(item => item is not null)!);
//
// #if MULTIKEY_USE_NEWTONSOFT_JSON
//     public class TestMultiDictNewtonsoftConverter : NJson.JsonConverter
//     {
//         public override bool CanConvert(Type objectType) => objectType == typeof(TestMultiDict);
//
//         public override void WriteJson(NJson.JsonWriter writer, object value, NJson.JsonSerializer serializer)
//         {
//             var dictionary = value as TestMultiDict;
//             if (dictionary == null)
//             {
//                 writer.WriteNull();
//                 return;
//             }
//
//             serializer.Serialize(writer, dictionary.Values);
//         }
//
//         public override object ReadJson(NJson.JsonReader reader, Type objectType, object existingValue, NJson.JsonSerializer serializer)
//         {
//             if (reader.TokenType == NJson.JsonToken.Null)
//                 return null;
//
//             var items = serializer.Deserialize<List<TestItem>>(reader);
//             if (items is null)
//                 return null;
//
//             return new TestMultiDict(items);
//         }
//     }
// #endif
//
//         public class ImmutableMultiKeyDictionarySystemConverter : SJson.JsonConverter<TestMultiDict>
//         {
//             public override TestMultiDict Read(ref Utf8JsonReader reader, Type typeToConvert,
//                 JsonSerializerOptions options)
//             {
//                 if (reader.TokenType != JsonTokenType.StartArray)
//                 {
//                     throw new JsonException("Invalid TestMultiDict serialization");
//                 }
//
//                 List<TestItem2> primary = new();
//
//                 while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)
//                 {
//                     var item = JsonSerializer.Deserialize<TestItem2>(ref reader, options);
//                     primary.Add(item!);
//                 }
//
//                 return new TestMultiDict(primary);
//             }
//
//             public override void Write(Utf8JsonWriter writer, TestMultiDict value, JsonSerializerOptions options)
//             {
//                 writer.WriteStartArray();
//
//                 foreach (var item in value.Values)
//                 {
//                     JsonSerializer.Serialize(writer, item, options);
//                 }
//
//                 writer.WriteEndArray();
//             }
//         }
//
//         public int Count => PrimaryIndex.Count;
//
//         IEnumerator<KeyValuePair<int, TestItem2>> IEnumerable<KeyValuePair<Int32, TestItem2>>.GetEnumerator()
//         {
//             return PrimaryIndex
//                 .Select(kvp => new KeyValuePair<Int32, TestItem2>(kvp.Key, _items[kvp.Value]!))
//                 .GetEnumerator();
//         }
//
//         public IEnumerator GetEnumerator()
//         {
//             return PrimaryIndex.GetEnumerator();
//         }
//     }
//
//     public static class TestMultiDictExtensions
//     {
//         public static TestMultiDict ToTestMultiDict(this IEnumerable<TestItem2> sequence)
//         {
//             return new(sequence);
//         }
//     }
// }
// #nullable restore