using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MultiKey.SourceGenerator;

[Generator]
public class MultiKeyDictionaryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<RecordDeclarationSyntax> recordDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => _isSyntaxTargetForGeneration(s),
                transform: (ctx, _) => _getSemanticTargetForGeneration(ctx))
            .Where(m => m is not null)!;
        
        IncrementalValueProvider<(Compilation, ImmutableArray<RecordDeclarationSyntax>)> compilationAndRecords
            = context.CompilationProvider.Combine(recordDeclarations.Collect());
        context.RegisterPostInitializationOutput(RegisterAttributeSource);
        context.RegisterSourceOutput(compilationAndRecords,
            static (spc, source) => _execute(source.Item1, source.Item2, spc));
    }
    
    private void RegisterAttributeSource(IncrementalGeneratorPostInitializationContext context)
    {
        var attributeSource = @"
// <auto-generated>
// This code was generated by a tool.
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;

namespace MultiKey
{
    [AttributeUsage(AttributeTargets.Class)]
    internal sealed class MultiKeyDictionaryAttribute<TKey, TKey2, TItem> : Attribute
    {
        public MultiKeyDictionaryAttribute(string selector1, string selector2)
        {
            Selector1 = selector1;
            Selector2 = selector2;
        }

        public string Selector1 { get; }
        public string Selector2 { get; }
    }

    [AttributeUsage(AttributeTargets.Class)]
    internal sealed class MultiKeyDictionaryAttribute<TKey, TKey2, TKey3, TItem> : Attribute
    {
        public MultiKeyDictionaryAttribute(string selector1, string selector2, string selector3)
        {
            Selector1 = selector1;
            Selector2 = selector2;
            Selector3 = selector3;
        }

        public string Selector1 { get; }
        public string Selector2 { get; }
        public string Selector3 { get; }
    }

    [AttributeUsage(AttributeTargets.Class)]
    internal sealed class MultiKeyDictionaryAttribute<TKey, TKey2, TKey3, TKey4, TItem> : Attribute
    {
        public MultiKeyDictionaryAttribute(string selector1, string selector2, string selector3, string selector4)
        {
            Selector1 = selector1;
            Selector2 = selector2;
            Selector3 = selector3;
            Selector4 = selector4;
        }

        public string Selector1 { get; }
        public string Selector2 { get; }
        public string Selector3 { get; }
        public string Selector4 { get; } 
    }
}
";
        context.AddSource("MultiKeyDictionaryAttribute.g.cs", attributeSource);
    }
    
    static bool _isSyntaxTargetForGeneration(SyntaxNode node) => 
        node is RecordDeclarationSyntax { AttributeLists.Count: > 0 };
    
    private static RecordDeclarationSyntax? _getSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var recordDeclarationSyntax = (RecordDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeListSyntax in recordDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue;
                }

                INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                string fullName = attributeContainingTypeSymbol.ToDisplayString();

                if (fullName.StartsWith("MultiKey.MultiKeyDictionary"))
                {
                    return recordDeclarationSyntax;
                }
            }
        }

        return null;
    }
    
    static void _execute(Compilation compilation, ImmutableArray<RecordDeclarationSyntax> records, SourceProductionContext context)
    {
        if (records.IsDefaultOrEmpty || context.CancellationToken.IsCancellationRequested)
        {
            return;
        }
        
        IEnumerable<RecordDeclarationSyntax> distinctRecords = records.Distinct();

        var recordsToGenerate = _generateRecords(compilation, distinctRecords, context, context.CancellationToken);

        foreach (var (fileName, content) in recordsToGenerate)
        {
            if (context.CancellationToken.IsCancellationRequested) break;
            
            context.AddSource($"{fileName}.generated.cs", SourceText.From(content, Encoding.UTF8));
        }
    }
    
    private static IEnumerable<(string fileName, string content)> _generateRecords(Compilation compilation, IEnumerable<RecordDeclarationSyntax> distinctRecords, SourceProductionContext _1, CancellationToken cancellationToken)
    {
        var recordDeclarationSyntax = distinctRecords.ToArray();
        for (int i = 0; i < recordDeclarationSyntax.Length && !cancellationToken.IsCancellationRequested; i++)
        {
            var semanticModel = compilation.GetSemanticModel(recordDeclarationSyntax[i].SyntaxTree);

            // Get the symbol representing the class
            var classSymbol = ModelExtensions.GetDeclaredSymbol(semanticModel, recordDeclarationSyntax[i]) as INamedTypeSymbol;

            if (classSymbol is null)
                continue;

            // Extract attribute information
            var multiKeyAttribute = classSymbol.GetAttributes()
                .FirstOrDefault(attr =>
                    attr.AttributeClass!.ToDisplayString().StartsWith("MultiKey.MultiKeyDictionaryAttribute<"));

            if (multiKeyAttribute == null) continue;

            int numberOfTypes = multiKeyAttribute.AttributeClass!.TypeArguments.Length;
            
            var key1Type = multiKeyAttribute.AttributeClass!.TypeArguments[0].Name;
            var key2Type = multiKeyAttribute.AttributeClass.TypeArguments[1].Name;
            string itemType;
            string selector1 = (string)multiKeyAttribute.ConstructorArguments[0].Value!;
            string selector2 = (string)multiKeyAttribute.ConstructorArguments[1].Value!;
            string dictName = classSymbol.Name;
            
            string nameSpace = SyntaxNodeHelper.GetNamespace(recordDeclarationSyntax[i], cancellationToken);
            
            var namespaces = new HashSet<string>
            {
                "System",
                "System.Collections",
                "System.Collections.Generic",
                "System.Collections.Immutable",
            };
            
            var symbols = recordDeclarationSyntax[i].DescendantNodes()
                .OfType<IdentifierNameSyntax>()
                .Select(identifier => ModelExtensions.GetSymbolInfo(semanticModel, identifier).Symbol)
                .Where(symbol => symbol is not null)
                .Distinct(SymbolEqualityComparer.Default);

            foreach (var symbol in symbols)
            {
                if (symbol!.ContainingNamespace != null && !symbol.ContainingNamespace.IsGlobalNamespace)
                {
                    namespaces.Add(symbol.ContainingNamespace.ToDisplayString());
                }
            }
            
            var parents = SyntaxNodeHelper
                .GetParentClasses(recordDeclarationSyntax[i], cancellationToken)
                .ToList();

            IEnumerable<StringBuilder> s;
            
            switch (numberOfTypes)
            {
                case 5: // 4 keys
                {
                    var key3Type = multiKeyAttribute.AttributeClass.TypeArguments[2].Name;
                    var selector3 = (string)multiKeyAttribute.ConstructorArguments[2].Value!;
                    var key4Type = multiKeyAttribute.AttributeClass.TypeArguments[3].Name;
                    var selector4 = (string)multiKeyAttribute.ConstructorArguments[3].Value!;
                    itemType = multiKeyAttribute.AttributeClass.TypeArguments[4].Name;
                    s = Template4(key1Type, key2Type, key3Type, key4Type, itemType, selector1, selector2, selector3, selector4, dictName)
                        .SplitLines()
                        .Select(o => new StringBuilder(o));
                    break;
                }
                case 4: // 3 keys
                {
                    var key3Type = multiKeyAttribute.AttributeClass.TypeArguments[2].Name;
                    var selector3 = (string)multiKeyAttribute.ConstructorArguments[2].Value!;
                    itemType = multiKeyAttribute.AttributeClass.TypeArguments[3].Name;
                    s = Template3(key1Type, key2Type, key3Type, itemType, selector1, selector2, selector3, dictName)
                        .SplitLines()
                        .Select(o => new StringBuilder(o));
                    break;
                }
                default: // 2 keys
                    itemType = multiKeyAttribute.AttributeClass.TypeArguments[2].Name;
                    s = Template2(key1Type, key2Type, itemType, selector1, selector2, dictName)
                        .SplitLines()
                        .Select(o => new StringBuilder(o));
                    break;
            }

            foreach (var (_, parentDeclaration) in parents)
            {
                s = SyntaxNodeHelper.IndentAndWrap(s, parentDeclaration, "}");
            }
            s = SyntaxNodeHelper.Wrap(s, $"namespace {nameSpace};\n");
            s = SyntaxNodeHelper.Wrap(s,"#if MULTIKEY_USE_NEWTONSOFT_JSON\nusing NJson = Newtonsoft.Json;\n#endif\n#if MULTIKEY_USE_SYSTEM_JSON\nusing System.Text.Json;\nusing SJson = System.Text.Json.Serialization;\n#endif\n");
            s = SyntaxNodeHelper.Wrap(s, 
                                    namespaces
                                            .OrderBy(ns => ns)
                                            .Aggregate(
                                                    new StringBuilder(), 
                                                    (acc, next) => acc.AppendLine($"using {next};")).ToString());
            
            s = SyntaxNodeHelper.Wrap(s, Header, Footer(dictName, itemType, parents.Select(parent => parent.name).ToList()));
            
            var content = s.Aggregate(new StringBuilder(), (acc, next) => acc.AppendLine(next.ToString())).ToString();
            
            yield return (fileName: $"{nameSpace.Replace(".", "_")}_{string.Join("-", parents.Select(p => p.name).Aggregate(new Stack<string>(), (acc, next) => { acc.Push(next); return acc; }).Concat(new[] { dictName })).Replace(".", "_")}", content);
        }
    }

    private const string Header = """
                                  // <auto-generated>
                                  // This code was generated by a tool.
                                  // Changes to this file may cause incorrect behavior 
                                  // and will be lost if the code is regenerated.
                                  // </auto-generated>

                                  /*
                                      To enable System.Text.Json, define the constant in your project: 
                                      MULTIKEY_USE_SYSTEM_JSON
                                      
                                      To enable Newtonsoft.Json, define the constant in your project: 
                                      MULTIKEY_USE_NEWTONSOFT_JSON
                                  */
                                  
                                  #nullable enable
                                  """;

    private static string Footer(string dictName, string itemType, List<string> wrappers) => $$"""
          
          public static class {{string.Join(string.Empty, wrappers)}}{{dictName}}Extensions
          {
              public static {{string.Join(".", wrappers)}}{{(wrappers.Any() ? "." : string.Empty)}}{{dictName}} To{{string.Join(string.Empty, wrappers)}}{{dictName}}(this IEnumerable<{{itemType}}> sequence)
              {
                  return new(sequence);
              }
          }
          
          #nullable restore
          """;
    
    private static string Template2(string key1Type,
        string key2Type,
        string itemType,
        string selector1,
        string selector2,
        string dictName) =>
        $$"""
          /// <summary>
          /// Represents a specialized immutable dictionary of {{itemType}}.
          /// </summary>
          /// <remarks>
          /// The <see cref="{{dictName}}"/> class provides efficient lookup capabilities 
          /// for items using both primary and secondary keys. The primary key allows for direct access to individual items,
          /// while the secondary key allows for grouped access to items sharing the same secondary key.
          /// </remarks>
          /// <example>
          /// The following example demonstrates how to use the <see cref="{{dictName}}"/>:
          /// <code>
          /// {{dictName}} dictionary = new {{dictName}}();
          /// {{key1Type}} primaryKey = /* any {{key1Type}} value */ default;
          /// {{key2Type}} secondaryKey = /* any {{key2Type}} value */ default;
          /// {{itemType}} byPrimary = dictionary[primaryKey]; // Returns 1 item or throws exception
          /// IReadOnlyList<{{itemType}}> bySecondary = dictionary.Get2(secondaryKey); // Returns 0+ items
          /// </code>
          /// </example>
          #if MULTIKEY_USE_NEWTONSOFT_JSON
          [NJson.JsonConverter(typeof({{dictName}}NewtonsoftConverter))]
          #endif
          #if MULTIKEY_USE_SYSTEM_JSON
          [SJson.JsonConverter(typeof({{dictName}}SystemConverter))]
          #endif
          public sealed partial record {{dictName}} : 
                IReadOnlyDictionary<{{key1Type}}, {{itemType}}>, 
                IEnumerable<KeyValuePair<{{key1Type}}, {{itemType}}>>
          {
             private readonly ImmutableList<{{itemType}}> _items;
          
             private ImmutableDictionary<{{key1Type}}, int>? _index1; // Will be initialized lazily
          
             private ImmutableDictionary<{{key2Type}}, ImmutableHashSet<int>>? _index2; // Will be initialized lazily
          
             static {{dictName}}()
             {
                 // These two assignments will be filled in by source generation, supplied by user
                 Selector1 = (Func<{{itemType}}, {{key1Type}}>)({{selector1}});
                 Selector2 = (Func<{{itemType}}, {{key2Type}}>)({{selector2}});
             }
          
             private static readonly Func<{{itemType}}, {{key1Type}}> Selector1;
          
             private static readonly Func<{{itemType}}, {{key2Type}}> Selector2;
          
             private ImmutableDictionary<{{key1Type}}, int> Index1 =>
                 _index1 ??= _items
                     .Select((item, index) => (item, index))
                     .Where(i => i.item is not null)
                     .ToImmutableDictionary(key => Selector1(key.item!), value => value.index);
          
             private ImmutableDictionary<{{key2Type}}, ImmutableHashSet<int>> Index2 =>
                 _index2 ??= _items
                     .Select((item, index) => (item, index))
                     .Where(i => i.item != null)
                     .GroupBy(item => Selector2(item.item!))
                     .ToImmutableDictionary(group => group.Key, group => group.Select(x => x.index).ToImmutableHashSet());
          
             public {{dictName}}()
             {
                 _items = new List<{{itemType}}>().ToImmutableList();
             }
          
             public {{dictName}}(IEnumerable<{{itemType}}> items)
             {
                 _items = items.ToImmutableList();
             }
          
             public {{itemType}} this[{{key1Type}} primary] => _items[Index1[primary]];
          
             public IEnumerable<{{key1Type}}> Keys => Index1.Keys;
             public IEnumerable<{{key2Type}}> Keys2 => Index2.Keys;
             public IEnumerable<{{itemType}}> Values => _items;
          
             public bool ContainsKey({{key1Type}} key) =>
                 Index1.ContainsKey(key);
          
             public bool ContainsKey2({{key2Type}} key) =>
                 Index2.ContainsKey(key);
          
             public bool TryGetValue({{key1Type}} primaryKey, out {{itemType}} item)
             {
                 if (Index1.TryGetValue(primaryKey, out var index))
                 {
                     item = _items[index];
                     return true;
                 }
          
                 item = default!;
                 return false;
             }
          
             public bool TryGetValue2({{key2Type}} secondaryKey, out IReadOnlyList<{{itemType}}> items)
             {
                 if (Index2.TryGetValue(secondaryKey, out var indexes))
                 {
                     items = indexes.Select(i => _items[i]).ToList().AsReadOnly();
                     return true;
                 }
          
                 items = default!;
                 return false;
             }
             
             public {{itemType}} Get({{key1Type}} primaryKey)
             {
                return this[primaryKey];
             }
             
             public IReadOnlyList<{{itemType}}> Get2({{key2Type}} secondaryKey)
             {
                return Index2.TryGetValue(secondaryKey, out var result)
                    ? result.Select(index => _items[index]).ToList().AsReadOnly()
                    : Enumerable.Empty<{{itemType}}>().ToList().AsReadOnly();
             }
          
             public {{dictName}} Add({{itemType}} item)
             {
                 var primaryKey = Selector1(item);
          
                 if (Index1.ContainsKey(primaryKey))
                     throw new ArgumentException("An item with the same primary key already exists in the dictionary.",
                         nameof(_index1));
          
                 return new(_items.Add(item));
             }
          
             public {{dictName}} Remove({{key1Type}} primary)
             {
                 if (!Index1.TryGetValue(primary, out var index))
                     return this;
          
                 return new(_items.Remove(_items[index]));
             }
          
             public {{dictName}} Remove({{itemType}} item) =>
                 new(_items.Remove(item));
          
             public {{dictName}} SetItem({{itemType}} item)
             {
                 var primaryKey = Selector1(item);
          
                 if (!Index1.TryGetValue(primaryKey, out var index))
                 {
                     return Add(item);
                 }
          
                 return new(_items.SetItem(index, item));
             }
          
             public {{dictName}} Compact() =>
                 new(_items.Where(item => item is not null));

          #if MULTIKEY_USE_NEWTONSOFT_JSON
          public class {{dictName}}NewtonsoftConverter : NJson.JsonConverter
          {
             public override bool CanConvert(Type objectType) => objectType == typeof({{dictName}});
          
             public override void WriteJson(NJson.JsonWriter writer, object? value, NJson.JsonSerializer serializer)
             {
                 var dictionary = value as {{dictName}};
                 if (dictionary is null)
                 {
                     writer.WriteNull();
                     return;
                 }
          
                 serializer.Serialize(writer, dictionary.Values);
             }
          
             public override object ReadJson(NJson.JsonReader reader, Type objectType, object? existingValue, NJson.JsonSerializer serializer)
             {
                 if (reader.TokenType == NJson.JsonToken.Null)
                     return null!;
          
                 var items = serializer.Deserialize<List<{{itemType}}>>(reader);
                 if (items is null)
                     return null!;
          
                 return new {{dictName}}(items);
             }
          }
          #endif
          
          #if MULTIKEY_USE_SYSTEM_JSON
             public class {{dictName}}SystemConverter : SJson.JsonConverter<{{dictName}}>
             {
                 public override {{dictName}} Read(ref Utf8JsonReader reader, Type typeToConvert,
                     JsonSerializerOptions options)
                 {
                     if (reader.TokenType != JsonTokenType.StartArray)
                     {
                         throw new JsonException("Invalid {{dictName}} serialization");
                     }
          
                     List<{{itemType}}> primary = new();
          
                     while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)
                     {
                         var item = JsonSerializer.Deserialize<{{itemType}}>(ref reader, options);
                         primary.Add(item!);
                     }
          
                     return new {{dictName}}(primary);
                 }
          
                 public override void Write(Utf8JsonWriter writer, {{dictName}} value, JsonSerializerOptions options)
                 {
                     writer.WriteStartArray();
          
                     foreach (var item in value.Values)
                     {
                         JsonSerializer.Serialize(writer, item, options);
                     }
          
                     writer.WriteEndArray();
                 }
             }
          #endif
          
             public int Count => Index1.Count;
          
             IEnumerator<KeyValuePair<{{key1Type}}, {{itemType}}>> IEnumerable<KeyValuePair<{{key1Type}}, {{itemType}}>>.GetEnumerator()
             {
                 return Index1
                     .Select(kvp => new KeyValuePair<{{key1Type}}, {{itemType}}>(kvp.Key, _items[kvp.Value]!))
                     .GetEnumerator();
             }
          
             public IEnumerator GetEnumerator()
             {
                  return Index1
                      .Select(kvp => new KeyValuePair<{{key1Type}}, {{itemType}}>(kvp.Key, _items[kvp.Value]!))
                      .GetEnumerator();
             }
          }
          """;
    
    private static string Template3(string key1Type,
        string key2Type,
        string key3Type,
        string itemType,
        string selector1,
        string selector2,
        string selector3,
        string dictName) =>
        $$"""
          /// <summary>
          /// Represents a specialized immutable dictionary of {{itemType}}.
          /// </summary>
          /// <remarks>
          /// The <see cref="{{dictName}}"/> class provides efficient lookup capabilities 
          /// for items using both primary and secondary keys. The primary key allows for direct access to individual items,
          /// while the secondary key allows for grouped access to items sharing the same secondary key.
          /// </remarks>
          /// <example>
          /// The following example demonstrates how to use the <see cref="{{dictName}}"/>:
          /// <code>
          /// {{dictName}} dictionary = new {{dictName}}();
          /// {{key1Type}} primaryKey = /* any {{key1Type}} value */ default;
          /// {{key2Type}} secondaryKey = /* any {{key2Type}} value */ default;
          /// {{key3Type}} tertiaryKey = /* any {{key3Type}} value */ default;
          /// {{itemType}} byPrimary = dictionary[primaryKey]; // Returns 1 item or throws exception
          /// IReadOnlyList<{{itemType}}> bySecondary = dictionary.Get2(secondaryKey); // Returns 0+ items
          /// IReadOnlyList<{{itemType}}> byTertiary = dictionary.Get3(tertiaryKey); // Returns 0+ items
          /// </code>
          /// </example>
          #if MULTIKEY_USE_NEWTONSOFT_JSON
          [NJson.JsonConverter(typeof({{dictName}}NewtonsoftConverter))]
          #endif
          #if MULTIKEY_USE_SYSTEM_JSON
          [SJson.JsonConverter(typeof({{dictName}}SystemConverter))]
          #endif
          public sealed partial record {{dictName}} : 
                IReadOnlyDictionary<{{key1Type}}, {{itemType}}>, 
                IEnumerable<KeyValuePair<{{key1Type}}, {{itemType}}>>
          {
             private readonly ImmutableList<{{itemType}}> _items;
          
             private ImmutableDictionary<{{key1Type}}, int>? _index1; // Will be initialized lazily
          
             private ImmutableDictionary<{{key2Type}}, ImmutableHashSet<int>>? _index2; // Will be initialized lazily
          
             private ImmutableDictionary<{{key3Type}}, ImmutableHashSet<int>>? _index3; // Will be initialized lazily
             
             static {{dictName}}()
             {
                 // These two assignments will be filled in by source generation, supplied by user
                 Selector1 = (Func<{{itemType}}, {{key1Type}}>)({{selector1}});
                 Selector2 = (Func<{{itemType}}, {{key2Type}}>)({{selector2}});
                 Selector3 = (Func<{{itemType}}, {{key3Type}}>)({{selector3}});
             }
          
             private static readonly Func<{{itemType}}, {{key1Type}}> Selector1;
          
             private static readonly Func<{{itemType}}, {{key2Type}}> Selector2;
          
             private static readonly Func<{{itemType}}, {{key3Type}}> Selector3;
             
             private ImmutableDictionary<{{key1Type}}, int> Index1 =>
                 _index1 ??= _items
                     .Select((item, index) => (item, index))
                     .Where(i => i.item is not null)
                     .ToImmutableDictionary(key => Selector1(key.item!), value => value.index);
          
             private ImmutableDictionary<{{key2Type}}, ImmutableHashSet<int>> Index2 =>
                 _index2 ??= _items
                     .Select((item, index) => (item, index))
                     .Where(i => i.item != null)
                     .GroupBy(item => Selector2(item.item!))
                     .ToImmutableDictionary(group => group.Key, group => group.Select(x => x.index).ToImmutableHashSet());
             
             private ImmutableDictionary<{{key3Type}}, ImmutableHashSet<int>> Index3 =>
                _index3 ??= _items
                      .Select((item, index) => (item, index))
                      .Where(i => i.item != null)
                      .GroupBy(item => Selector3(item.item!))
                      .ToImmutableDictionary(group => group.Key, group => group.Select(x => x.index).ToImmutableHashSet());
             
             public {{dictName}}()
             {
                 _items = new List<{{itemType}}>().ToImmutableList();
             }
          
             public {{dictName}}(IEnumerable<{{itemType}}> items)
             {
                 _items = items.ToImmutableList();
             }
          
             public {{itemType}} this[{{key1Type}} primary] => _items[Index1[primary]];
          
             public IEnumerable<{{key1Type}}> Keys => Index1.Keys;
             public IEnumerable<{{key2Type}}> Keys2 => Index2.Keys;
             public IEnumerable<{{key3Type}}> Keys3 => Index3.Keys;
             public IEnumerable<{{itemType}}> Values => _items;
          
             public bool ContainsKey({{key1Type}} key) =>
                 Index1.ContainsKey(key);
          
             public bool ContainsKey2({{key2Type}} key) =>
                 Index2.ContainsKey(key);
                 
             public bool ContainsKey3({{key3Type}} key) =>
                 Index3.ContainsKey(key);
          
             public bool TryGetValue({{key1Type}} primaryKey, out {{itemType}} item)
             {
                 if (Index1.TryGetValue(primaryKey, out var index))
                 {
                     item = _items[index];
                     return true;
                 }
          
                 item = default!;
                 return false;
             }
          
             public bool TryGetValue2({{key2Type}} secondaryKey, out IReadOnlyList<{{itemType}}> items)
             {
                 if (Index2.TryGetValue(secondaryKey, out var indexes))
                 {
                     items = indexes.Select(i => _items[i]).ToList().AsReadOnly();
                     return true;
                 }
          
                 items = default!;
                 return false;
             }
             
             public bool TryGetValue3({{key3Type}} tertiaryKey, out IReadOnlyList<{{itemType}}> items)
             {
                 if (Index3.TryGetValue(tertiaryKey, out var indexes))
                 {
                     items = indexes.Select(i => _items[i]).ToList().AsReadOnly();
                     return true;
                 }
             
                 items = default!;
                 return false;
             }
             
             public {{itemType}} Get({{key1Type}} primaryKey)
             {
                return this[primaryKey];
             }
             
             public IReadOnlyList<{{itemType}}> Get2({{key2Type}} secondaryKey)
             {
                return Index2.TryGetValue(secondaryKey, out var result)
                    ? result.Select(index => _items[index]).ToList().AsReadOnly()
                    : Enumerable.Empty<{{itemType}}>().ToList().AsReadOnly();
             }
             
             public IReadOnlyList<{{itemType}}> Get3({{key3Type}} tertiaryKey)
             {
                return Index3.TryGetValue(tertiaryKey, out var result)
                    ? result.Select(index => _items[index]).ToList().AsReadOnly()
                    : Enumerable.Empty<{{itemType}}>().ToList().AsReadOnly();
             }
          
             public {{dictName}} Add({{itemType}} item)
             {
                 var primaryKey = Selector1(item);
          
                 if (Index1.ContainsKey(primaryKey))
                     throw new ArgumentException("An item with the same primary key already exists in the dictionary.",
                         nameof(_index1));
          
                 return new(_items.Add(item));
             }
          
             public {{dictName}} Remove({{key1Type}} primary)
             {
                 if (!Index1.TryGetValue(primary, out var index))
                     return this;
          
                 return new(_items.Remove(_items[index]));
             }
          
             public {{dictName}} Remove({{itemType}} item) =>
                 new(_items.Remove(item));
          
             public {{dictName}} SetItem({{itemType}} item)
             {
                 var primaryKey = Selector1(item);
          
                 if (!Index1.TryGetValue(primaryKey, out var index))
                 {
                     return Add(item);
                 }
          
                 return new(_items.SetItem(index, item));
             }
          
             public {{dictName}} Compact() =>
                 new(_items.Where(item => item is not null));

          #if MULTIKEY_USE_NEWTONSOFT_JSON
          public class {{dictName}}NewtonsoftConverter : NJson.JsonConverter
          {
             public override bool CanConvert(Type objectType) => objectType == typeof({{dictName}});
          
             public override void WriteJson(NJson.JsonWriter writer, object? value, NJson.JsonSerializer serializer)
             {
                 var dictionary = value as {{dictName}};
                 if (dictionary is null)
                 {
                     writer.WriteNull();
                     return;
                 }
          
                 serializer.Serialize(writer, dictionary.Values);
             }
          
             public override object ReadJson(NJson.JsonReader reader, Type objectType, object? existingValue, NJson.JsonSerializer serializer)
             {
                 if (reader.TokenType == NJson.JsonToken.Null)
                     return null!;
          
                 var items = serializer.Deserialize<List<{{itemType}}>>(reader);
                 if (items is null)
                     return null!;
          
                 return new {{dictName}}(items);
             }
          }
          #endif
          
          #if MULTIKEY_USE_SYSTEM_JSON
             public class {{dictName}}SystemConverter : SJson.JsonConverter<{{dictName}}>
             {
                 public override {{dictName}} Read(ref Utf8JsonReader reader, Type typeToConvert,
                     JsonSerializerOptions options)
                 {
                     if (reader.TokenType != JsonTokenType.StartArray)
                     {
                         throw new JsonException("Invalid {{dictName}} serialization");
                     }
          
                     List<{{itemType}}> primary = new();
          
                     while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)
                     {
                         var item = JsonSerializer.Deserialize<{{itemType}}>(ref reader, options);
                         primary.Add(item!);
                     }
          
                     return new {{dictName}}(primary);
                 }
          
                 public override void Write(Utf8JsonWriter writer, {{dictName}} value, JsonSerializerOptions options)
                 {
                     writer.WriteStartArray();
          
                     foreach (var item in value.Values)
                     {
                         JsonSerializer.Serialize(writer, item, options);
                     }
          
                     writer.WriteEndArray();
                 }
             }
          #endif
          
             public int Count => Index1.Count;
          
             IEnumerator<KeyValuePair<{{key1Type}}, {{itemType}}>> IEnumerable<KeyValuePair<{{key1Type}}, {{itemType}}>>.GetEnumerator()
             {
                 return Index1
                     .Select(kvp => new KeyValuePair<{{key1Type}}, {{itemType}}>(kvp.Key, _items[kvp.Value]!))
                     .GetEnumerator();
             }
          
             public IEnumerator GetEnumerator()
             {
                  return Index1
                      .Select(kvp => new KeyValuePair<{{key1Type}}, {{itemType}}>(kvp.Key, _items[kvp.Value]!))
                      .GetEnumerator();
             }
          }
          """;
    
private static string Template4(string key1Type,
        string key2Type,
        string key3Type,
        string key4Type,
        string itemType,
        string selector1,
        string selector2,
        string selector3,
        string selector4,
        string dictName) =>
        $$"""
          /// <summary>
          /// Represents a specialized immutable dictionary of {{itemType}}.
          /// </summary>
          /// <remarks>
          /// The <see cref="{{dictName}}"/> class provides efficient lookup capabilities 
          /// for items using both primary and secondary keys. The primary key allows for direct access to individual items,
          /// while the secondary key allows for grouped access to items sharing the same secondary key.
          /// </remarks>
          /// <example>
          /// The following example demonstrates how to use the <see cref="{{dictName}}"/>:
          /// <code>
          /// {{dictName}} dictionary = new {{dictName}}();
          /// {{key1Type}} primaryKey = /* any {{key1Type}} value */ default;
          /// {{key2Type}} secondaryKey = /* any {{key2Type}} value */ default;
          /// {{key3Type}} tertiaryKey = /* any {{key3Type}} value */ default;
          /// {{key4Type}} quaternaryKey = /* any {{key4Type}} value */ default;
          /// {{itemType}} byPrimary = dictionary[primaryKey]; // Returns 1 item or throws exception
          /// IReadOnlyList<{{itemType}}> bySecondary = dictionary.Get2(secondaryKey); // Returns 0+ items
          /// IReadOnlyList<{{itemType}}> byTertiary = dictionary.Get3(tertiaryKey); // Returns 0+ items
          /// IReadOnlyList<{{itemType}}> byQuaternary = dictionary.Get4(quaternaryKey); // Returns 0+ items
          /// </code>
          /// </example>
          #if MULTIKEY_USE_NEWTONSOFT_JSON
          [NJson.JsonConverter(typeof({{dictName}}NewtonsoftConverter))]
          #endif
          #if MULTIKEY_USE_SYSTEM_JSON
          [SJson.JsonConverter(typeof({{dictName}}SystemConverter))]
          #endif
          public sealed partial record {{dictName}} : 
                IReadOnlyDictionary<{{key1Type}}, {{itemType}}>, 
                IEnumerable<KeyValuePair<{{key1Type}}, {{itemType}}>>
          {
             private readonly ImmutableList<{{itemType}}> _items;
          
             private ImmutableDictionary<{{key1Type}}, int>? _index1; // Will be initialized lazily
          
             private ImmutableDictionary<{{key2Type}}, ImmutableHashSet<int>>? _index2; // Will be initialized lazily
          
             private ImmutableDictionary<{{key3Type}}, ImmutableHashSet<int>>? _index3; // Will be initialized lazily
             
             private ImmutableDictionary<{{key4Type}}, ImmutableHashSet<int>>? _index4; // Will be initialized lazily
          
             static {{dictName}}()
             {
                 // These two assignments will be filled in by source generation, supplied by user
                 Selector1 = (Func<{{itemType}}, {{key1Type}}>)({{selector1}});
                 Selector2 = (Func<{{itemType}}, {{key2Type}}>)({{selector2}});
                 Selector3 = (Func<{{itemType}}, {{key3Type}}>)({{selector3}});
                 Selector4 = (Func<{{itemType}}, {{key4Type}}>)({{selector4}});
             }
          
             private static readonly Func<{{itemType}}, {{key1Type}}> Selector1;
          
             private static readonly Func<{{itemType}}, {{key2Type}}> Selector2;
          
             private static readonly Func<{{itemType}}, {{key3Type}}> Selector3;
             
             private static readonly Func<{{itemType}}, {{key4Type}}> Selector4;
             
             private ImmutableDictionary<{{key1Type}}, int> Index1 =>
                 _index1 ??= _items
                     .Select((item, index) => (item, index))
                     .Where(i => i.item is not null)
                     .ToImmutableDictionary(key => Selector1(key.item!), value => value.index);
          
             private ImmutableDictionary<{{key2Type}}, ImmutableHashSet<int>> Index2 =>
                 _index2 ??= _items
                     .Select((item, index) => (item, index))
                     .Where(i => i.item != null)
                     .GroupBy(item => Selector2(item.item!))
                     .ToImmutableDictionary(group => group.Key, group => group.Select(x => x.index).ToImmutableHashSet());
             
             private ImmutableDictionary<{{key3Type}}, ImmutableHashSet<int>> Index3 =>
                _index3 ??= _items
                      .Select((item, index) => (item, index))
                      .Where(i => i.item != null)
                      .GroupBy(item => Selector3(item.item!))
                      .ToImmutableDictionary(group => group.Key, group => group.Select(x => x.index).ToImmutableHashSet());
             
             private ImmutableDictionary<{{key4Type}}, ImmutableHashSet<int>> Index4 =>
                _index4 ??= _items
                       .Select((item, index) => (item, index))
                       .Where(i => i.item != null)
                       .GroupBy(item => Selector4(item.item!))
                       .ToImmutableDictionary(group => group.Key, group => group.Select(x => x.index).ToImmutableHashSet());
             
             public {{dictName}}()
             {
                 _items = new List<{{itemType}}>().ToImmutableList();
             }
          
             public {{dictName}}(IEnumerable<{{itemType}}> items)
             {
                 _items = items.ToImmutableList();
             }
          
             public {{itemType}} this[{{key1Type}} primary] => _items[Index1[primary]];
          
             public IEnumerable<{{key1Type}}> Keys => Index1.Keys;
             public IEnumerable<{{key2Type}}> Keys2 => Index2.Keys;
             public IEnumerable<{{key3Type}}> Keys3 => Index3.Keys;
             public IEnumerable<{{key4Type}}> Keys4 => Index4.Keys;
             public IEnumerable<{{itemType}}> Values => _items;
          
             public bool ContainsKey({{key1Type}} key) =>
                 Index1.ContainsKey(key);
          
             public bool ContainsKey2({{key2Type}} key) =>
                 Index2.ContainsKey(key);
                 
             public bool ContainsKey3({{key3Type}} key) =>
                 Index3.ContainsKey(key);
                 
             public bool ContainsKey4({{key4Type}} key) =>
                 Index4.ContainsKey(key);
          
             public bool TryGetValue({{key1Type}} primaryKey, out {{itemType}} item)
             {
                 if (Index1.TryGetValue(primaryKey, out var index))
                 {
                     item = _items[index];
                     return true;
                 }
          
                 item = default!;
                 return false;
             }
          
             public bool TryGetValue2({{key2Type}} secondaryKey, out IReadOnlyList<{{itemType}}> items)
             {
                 if (Index2.TryGetValue(secondaryKey, out var indexes))
                 {
                     items = indexes.Select(i => _items[i]).ToList().AsReadOnly();
                     return true;
                 }
          
                 items = default!;
                 return false;
             }
             
             public bool TryGetValue3({{key3Type}} tertiaryKey, out IReadOnlyList<{{itemType}}> items)
             {
                 if (Index3.TryGetValue(tertiaryKey, out var indexes))
                 {
                     items = indexes.Select(i => _items[i]).ToList().AsReadOnly();
                     return true;
                 }
             
                 items = default!;
                 return false;
             }
             
             public bool TryGetValue4({{key4Type}} quaternaryKey, out IReadOnlyList<{{itemType}}> items)
             {
                 if (Index4.TryGetValue(quaternaryKey, out var indexes))
                 {
                     items = indexes.Select(i => _items[i]).ToList().AsReadOnly();
                     return true;
                 }
             
                 items = default!;
                 return false;
             }
             
             public {{itemType}} Get({{key1Type}} primaryKey)
             {
                return this[primaryKey];
             }
             
             public IReadOnlyList<{{itemType}}> Get2({{key2Type}} secondaryKey)
             {
                return Index2.TryGetValue(secondaryKey, out var result)
                    ? result.Select(index => _items[index]).ToList().AsReadOnly()
                    : Enumerable.Empty<{{itemType}}>().ToList().AsReadOnly();
             }
             
             public IReadOnlyList<{{itemType}}> Get3({{key3Type}} tertiaryKey)
             {
                return Index3.TryGetValue(tertiaryKey, out var result)
                    ? result.Select(index => _items[index]).ToList().AsReadOnly()
                    : Enumerable.Empty<{{itemType}}>().ToList().AsReadOnly();
             }
             
             public IReadOnlyList<{{itemType}}> Get4({{key4Type}} quaternaryKey)
             {
                return Index4.TryGetValue(quaternaryKey, out var result)
                    ? result.Select(index => _items[index]).ToList().AsReadOnly()
                    : Enumerable.Empty<{{itemType}}>().ToList().AsReadOnly();
             }
          
             public {{dictName}} Add({{itemType}} item)
             {
                 var primaryKey = Selector1(item);
          
                 if (Index1.ContainsKey(primaryKey))
                     throw new ArgumentException("An item with the same primary key already exists in the dictionary.",
                         nameof(_index1));
          
                 return new(_items.Add(item));
             }
          
             public {{dictName}} Remove({{key1Type}} primary)
             {
                 if (!Index1.TryGetValue(primary, out var index))
                     return this;
          
                 return new(_items.Remove(_items[index]));
             }
          
             public {{dictName}} Remove({{itemType}} item) =>
                 new(_items.Remove(item));
          
             public {{dictName}} SetItem({{itemType}} item)
             {
                 var primaryKey = Selector1(item);
          
                 if (!Index1.TryGetValue(primaryKey, out var index))
                 {
                     return Add(item);
                 }
          
                 return new(_items.SetItem(index, item));
             }
          
             public {{dictName}} Compact() =>
                 new(_items.Where(item => item is not null));

          #if MULTIKEY_USE_NEWTONSOFT_JSON
          public class {{dictName}}NewtonsoftConverter : NJson.JsonConverter
          {
             public override bool CanConvert(Type objectType) => objectType == typeof({{dictName}});
          
             public override void WriteJson(NJson.JsonWriter writer, object? value, NJson.JsonSerializer serializer)
             {
                 var dictionary = value as {{dictName}};
                 if (dictionary is null)
                 {
                     writer.WriteNull();
                     return;
                 }
          
                 serializer.Serialize(writer, dictionary.Values);
             }
          
             public override object ReadJson(NJson.JsonReader reader, Type objectType, object? existingValue, NJson.JsonSerializer serializer)
             {
                 if (reader.TokenType == NJson.JsonToken.Null)
                     return null!;
          
                 var items = serializer.Deserialize<List<{{itemType}}>>(reader);
                 if (items is null)
                     return null!;
          
                 return new {{dictName}}(items);
             }
          }
          #endif
          
          #if MULTIKEY_USE_SYSTEM_JSON
             public class {{dictName}}SystemConverter : SJson.JsonConverter<{{dictName}}>
             {
                 public override {{dictName}} Read(ref Utf8JsonReader reader, Type typeToConvert,
                     JsonSerializerOptions options)
                 {
                     if (reader.TokenType != JsonTokenType.StartArray)
                     {
                         throw new JsonException("Invalid {{dictName}} serialization");
                     }
          
                     List<{{itemType}}> primary = new();
          
                     while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)
                     {
                         var item = JsonSerializer.Deserialize<{{itemType}}>(ref reader, options);
                         primary.Add(item!);
                     }
          
                     return new {{dictName}}(primary);
                 }
          
                 public override void Write(Utf8JsonWriter writer, {{dictName}} value, JsonSerializerOptions options)
                 {
                     writer.WriteStartArray();
          
                     foreach (var item in value.Values)
                     {
                         JsonSerializer.Serialize(writer, item, options);
                     }
          
                     writer.WriteEndArray();
                 }
             }
          #endif
          
             public int Count => Index1.Count;
          
             IEnumerator<KeyValuePair<{{key1Type}}, {{itemType}}>> IEnumerable<KeyValuePair<{{key1Type}}, {{itemType}}>>.GetEnumerator()
             {
                 return Index1
                     .Select(kvp => new KeyValuePair<{{key1Type}}, {{itemType}}>(kvp.Key, _items[kvp.Value]!))
                     .GetEnumerator();
             }
          
             public IEnumerator GetEnumerator()
             {
                  return Index1
                      .Select(kvp => new KeyValuePair<{{key1Type}}, {{itemType}}>(kvp.Key, _items[kvp.Value]!))
                      .GetEnumerator();
             }
          }
          """;
}

public static class SyntaxNodeHelper
{
    public static string GetNamespace(BaseTypeDeclarationSyntax syntax, CancellationToken cancellationToken)
    {
        StringBuilder nameSpace = default!;

        SyntaxNode? potentialNamespaceParent = syntax.Parent;

        while (potentialNamespaceParent != null &&
                potentialNamespaceParent is not NamespaceDeclarationSyntax
                && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax
                && !cancellationToken.IsCancellationRequested)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            nameSpace = new StringBuilder(namespaceParent.Name.ToString());

            while (namespaceParent.Parent is NamespaceDeclarationSyntax parent && !cancellationToken.IsCancellationRequested)
            {
                nameSpace.Insert(0, ".");
                nameSpace = nameSpace.Insert(0, namespaceParent.Name);
                namespaceParent = parent;
            }
        }
        return nameSpace.ToString();
    }

    public static IEnumerable<(string name, string declaration)> GetParentClasses(BaseTypeDeclarationSyntax typeSyntax, CancellationToken cancellationToken)
    {
        TypeDeclarationSyntax? parentSyntax = typeSyntax.Parent as TypeDeclarationSyntax;

        while (parentSyntax != null && _isAllowedKind(parentSyntax.Kind()) && !cancellationToken.IsCancellationRequested)
        {
            yield return (name: parentSyntax.Identifier.ToString(), declaration: $"{parentSyntax.Modifiers} {parentSyntax.Keyword} {parentSyntax.Identifier}\n{{");

            parentSyntax = parentSyntax.Parent as TypeDeclarationSyntax;
        }
    }

    private static bool _isAllowedKind(SyntaxKind kind) =>
        kind is SyntaxKind.ClassDeclaration or SyntaxKind.StructDeclaration or SyntaxKind.RecordDeclaration;

    public static IEnumerable<StringBuilder> IndentAndWrap(IEnumerable<StringBuilder> s, string preWrap, string postWrap) =>
        Wrap(s.Select(Indent), preWrap, postWrap);

    public static IEnumerable<StringBuilder> Wrap(IEnumerable<StringBuilder> s, string preWrap, string postWrap) =>
        preWrap.SplitLines().Select(o => new StringBuilder(o)).Concat(s).Concat(postWrap.SplitLines().Select(o => new StringBuilder(o)));

    public static IEnumerable<StringBuilder> Wrap(IEnumerable<StringBuilder> s, string preWrap) =>
        preWrap.SplitLines().Select(o => new StringBuilder(o)).Concat(s);
    
    public static IReadOnlyList<string> SplitLines(this string lines) =>
        lines.Split(new[] { "\n" }, StringSplitOptions.None).ToList().AsReadOnly();
    
    private static StringBuilder Indent(StringBuilder s) =>
        s.Length == 0 || s[0] == '#' 
            ? s
            : s.Insert(0, "    ");
}